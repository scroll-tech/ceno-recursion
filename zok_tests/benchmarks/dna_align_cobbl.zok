/*
 * Computes the Longest Common Subsequence of two strings, one of 
 * length m and the other of length n in O(m*n) time
 */
def main(field b, field n) -> field:
    field[4] A = [0; 4]
    field[4] B = [0; 4]
    field[4] LCS = [0; 4]
    field arr_size = 4

    field i = 0
    field j = 0

    // Dynamic programming memo
    field[16] LL = [0; 16]
    // Hold choices made at each step, for use when backtracking
    field[16] choices = [0; 16]
    // Used when backtracking
    field diag = 0
    field down = 0
    field right = 0

    // Go backwards from i = n-1 downto 0
    field i_iter = n
    while i_iter > 0 do
        field i = i_iter - 1
        field j_iter = n
        while j_iter > 0 do
            field j = j_iter - 1
            if A[i] == B[j] then
                if 0 <= i+1 && i+1 < n && 0 <= j+1 && j+1 < n then
                    diag = LL[(i+1) * arr_size + j+1]
                else
                    diag = 0
                endif
                // Diagonal jump
                LL[i * arr_size + j] = 1 + diag
                choices[i * arr_size + j] = 0
            else
                if 0 <= i+1 && i+1 < n && 0 <= j && j < n then
                    down = LL[(i+1) * arr_size + j]
                else 
                    down = 0
                endif
                if 0 <= i && i < n && 0 <= j+1 && j+1 < n then
                    right = LL[i * arr_size + j+1]
                else
                    right = 0
                endif
                // Assertion: down and right differ by at most 1
                if down == right + 1 then
                    // Jump down
                    LL[i * arr_size + j] = down
                    choices[i * arr_size + j] = 1
                else
                    // Jump right if down == right or right == down + 1.
                    LL[i * arr_size + j] = right
                    choices[i * arr_size + j] = 2
                endif
            endif
            j_iter = j_iter - 1
        endwhile
        i_iter = i_iter - 1
    endwhile


    // Construct LCS, allowing it to have intermittent zero characters
    field iPtr = 0
    field jPtr = 0 // Pointers to where in LL we are with respect to backtracking

    field i = 0
    while i < n do
        LCS[i] = 0 //If A[i] is not in the LCS, this remains 0.
        field j = 0
        while j < n do
            if i == iPtr && j == jPtr then // Loop until we meet up with the iPtr and jPtr
                if choices[i * arr_size + j] == 0 then // we made a diagonal jump here
                    LCS[i] = A[i]
                    iPtr = iPtr + 1
                    jPtr = jPtr + 1
                else
                    if choices[i * arr_size + j] == 1 then // jump down
                        iPtr = iPtr + 1
                    else // jump right
                        jPtr = jPtr + 1
                    endif
                endif
            endif
            j = j + 1
        endwhile
        i = i + 1
    endwhile

    // Now move any string terminator (\0) characters in LCS to the end ala insertion sort
    field i = 1
    while i < n do
        field inserted = 0
        field j = 0
        while j < i do
            if LCS[j] == 0 && inserted == 0 then
                // Swap LCS[j] and LCS[i].
                LCS[j] = LCS[i]
                LCS[i] = 0
                inserted = 1
            endif
            j = j + 1
        endwhile
        i = i + 1
    endwhile


    return LCS[b]