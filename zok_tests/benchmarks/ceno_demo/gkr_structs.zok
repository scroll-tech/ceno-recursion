from "sumcheck_structs" import SumcheckProof

struct PointAndEval {
    u32 d // d = point.len()
    field[0] point
    field eval
}

struct LayeredPointAndEval {
    u32 layer_id
    PointAndEval point_and_eval
}

struct GkrIOPVerifierState {
    u32 layer_id
    u32 to_next_phase_point_and_evals_len
    PointAndEval[0] to_next_phase_point_and_evals
    u32[0] subset_point_and_evals_len
    LayeredPointAndEval[0][0] subset_point_and_evals
    field[0][0] challenges
    u32 instance_num_vars
    PointAndEval to_next_step_point_and_eval

    field[0] assert_point
    field[0] g1_values
    field[0] out_point
    field[0] eq_y_ry
    field[0] eq_x1_rx1
    field[0] eq_x2_rx2
}

// SumcheckStepType
const field OutputPhase1Step1 = 0
const field OutputPhase1Step2 = 1
const field Phase1Step1 = 2
const field Phase2Step1 = 3
const field Phase2Step2 = 4
const field Phase2Step2NoStep3 = 5
const field Phase2Step3 = 6
const field LinearPhase2Step1 = 7
const field InputPhase2Step1 = 8
const field Undefined = 9

struct Gate {
    field c
    field fan_in
}

struct Layer {
    u32 layer_id
    u32 num_sumcheck_steps
    field[0] sumcheck_steps
    u32 num_vars

    // Gates. Should be all None if it's the input layer.
    Gate[0] add_consts
    Gate[0] adds
    /*
    pub(crate) adds_fanin_mapping: [BTreeMap<CellId, Vec<Gate1In<ConstantType<E>>>>; 1], // grouping for 1 fanins
    pub(crate) mul2s: Vec<Gate2In<ConstantType<E>>>,
    pub(crate) mul2s_fanin_mapping: [BTreeMap<CellId, Vec<Gate2In<ConstantType<E>>>>; 2], // grouping for 2 fanins
    pub(crate) mul3s: Vec<Gate3In<ConstantType<E>>>,
    pub(crate) mul3s_fanin_mapping: [BTreeMap<CellId, Vec<Gate3In<ConstantType<E>>>>; 3], // grouping for 3 fanins

    /// The corresponding wires copied from this layer to later layers. It is
    /// (later layer id -> current wire id to be copied). It stores the non-zero
    /// entry of copy_to[layer_id] for each row.
    pub(crate) copy_to: BTreeMap<LayerId, Vec<CellId>>,
    /// The corresponding wires from previous layers pasted to this layer. It is
    /// (shallower layer id -> pasted to the current id). It stores the non-zero
    /// entry of paste_from[layer_id] for each column. Undefined for the input.
    pub(crate) paste_from: BTreeMap<LayerId, Vec<CellId>>,
    /// Maximum size of the subsets pasted from the previous layers, rounded up
    /// to the next power of two. This is the logarithm of the rounded size.
    /// Undefined for the input layer.
    pub(crate) max_previous_num_vars: usize,
    */
}

struct Cell {
    u32 x
    u32 y
}

struct Counter {
    u32 count
    Cell cell
}

struct Circuit {
    u32 num_layers
    Layer[0] layers
    u32 n_witness_in
    u32 n_witness_out
    /// The endpoints in the input layer copied from each input witness.
    Cell[0] paste_from_wits_in
    /// The endpoints in the input layer copied from counter.
    Counter[0] paste_from_counter_in
    /// The endpoints in the input layer copied from constants
    Counter[0] paste_from_consts_in
    /// The wires copied to the output witness
    u32[0][0] copy_to_wits_out
    Gate[0] assert_consts
    u32 max_wit_in_num_vars
}

struct IOPProverStepMessage {
    SumcheckProof sumcheck_proof
    field[0] sumcheck_eval_values
}

struct IOPProof {
    IOPProverStepMessage[0] sumcheck_proofs
}

struct GkrInputClaims {
    PointAndEval[0] point_and_evals
}