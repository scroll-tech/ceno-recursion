from "./poseidon.zok" import poseidon, ark, sbox, mix
from "./merkle.zok" import MerkleProof, verify_merkle

// Reveal Proof Entry
struct T {
    u32 i
    field[5] s // sig_r_x, sig_r_y, sig_s, l, r
    MerkleProof pi_s
    field[5] p // sig_r_x, sig_r_y, sig_s, weight, 0
    MerkleProof pi_p
}

struct CompactCertProof {
    field sig_root
    u32 signed_weight
    T[0] t_list
}

// Verifier of a compact certificate function
def verifier(
    CompactCertProof compact_cert_proof,
    u32 proven_weight,
    u32 num_reveals,
    field message,
    u32 merkle_depth,
    field att_root,
    Signature[0] sigs,
) -> u32:
    u32 signed_weight = compact_cert_proof.signed_weight
    assert(signed_weight > proven_weight)
    // let num_reveals: usize = (k + q).div_ceil((signed_weight / proven_weight).ilog2() as usize);

    for u32 j in 0..num_reveals do
        // Reproduce coin
        field[5] inputs = [(F)j, compact_cert_proof.sig_root, (F)proven_weight, message, att_root]
        field coin_hash = poseidon(5, inputs)
        // field coin = coin_hash % (F)signed_weight
        field coin = 5

        T t = compact_cert_proof.t_list[j]
        // Sig Opening
        assert(verify_merkle(t.pi_s, compact_cert_proof.sig_root, t.i, t.s, merkle_depth))
        // Att Opening
        assert(verify_merkle(t.pi_p, att_root, t.i, t.p, merkle_depth))
        // Correspondence of signature
        assert(t.s[0] == t.p[0])
        // Validity of signature
        
        // L < coin <= L + Weight
        assert(t.s[1] <= coin && coin < t.s[1] + t.p[2])
    endfor

    return 1

def main() -> u32:
    field message = 798
    // attestors: [0, 0, 1], [1, 1, 2], [2, 2, 3], [3, 3, 4]
    // att internals: [368191096817780402688216664640044494471463724502444509207532685924843993798, 4987682793450643737301756561296924932463644342307846743150842019815678868756]
    field att_root = 7199931385403621423989853091721173338948015710744744776965348678666432056017
    // sigs: [0, 0, 1], [1, 1, 3], [2, 3, 6], [3, 6, 10]
    // sig internals: [981393290388939892298576508269309645432298498866464364767232692132970656763, 2559145465398517868851519407883502523317753908862093834922805078206432530660]
    field sig_root = 1363862103427411396879257859619074537598816635279934461296185382254981660079
    u32 merkle_depth = 2

    u32 proven_weight = 7
    u32 signed_weight = 10
    // Coin is poseidon(0, sig_root, proven_weight, message, att_root) % signed_weight
    field coin = 5
    // Coin 5 corresponds to attestor 2, generate sig_proof and att_proof
    T t_0 = T {
        i: 2,
        s: [2, 3, 6],
        pi_s: MerkleProof {
            leaf: [3, 6, 10],
            path: [981393290388939892298576508269309645432298498866464364767232692132970656763],
            bits: [0, 1]
        },
        p: [2, 2, 3],
        pi_p: MerkleProof {
            leaf: [3, 3, 4],
            path: [368191096817780402688216664640044494471463724502444509207532685924843993798],
            bits: [0, 1]
        }
    }
    CompactCertProof compact_cert_proof = CompactCertProof {
        sig_root: sig_root,
        signed_weight: signed_weight,
        t_list: [t_0]
    }

    return verifier(
        compact_cert_proof,
        proven_weight,
        1,
        message,
        merkle_depth,
        att_root
    )