@misc{ozdemir20circ,
      author = {Alex Ozdemir and Fraser Brown and Riad S.  Wahby},
      title = {CirC: Compiler infrastructure for proof systems, software verification, and more},
      howpublished = {Cryptology ePrint Archive, Paper 2020/1586},
      year = {2020},
      note = {\url{https://eprint.iacr.org/2020/1586}},
      url = {https://eprint.iacr.org/2020/1586}
}

@INPROCEEDINGS{zhang18vram,
  author={Zhang, Yupeng and Genkin, Daniel and Katz, Jonathan and Papadopoulos, Dimitrios and Papamanthou, Charalampos},
  booktitle={2018 IEEE Symposium on Security and Privacy (SP)}, 
  title={vRAM: Faster Verifiable RAM with Program-Independent Preprocessing}, 
  year={2018},
  volume={},
  number={},
  pages={908-925},
  keywords={Random access memory;Protocols;Data preprocessing;Memory management;Central Processing Unit;Upper bound;Verifiable Computation;Cloud Security;Verifiable RAM Program},
  doi={10.1109/SP.2018.00013}
}

@misc{wahby14buffet,
      author = {Riad S.  Wahby and Srinath Setty and Max Howald and Zuocheng Ren and Andrew J.  Blumberg and Michael Walfish},
      title = {Efficient RAM and control flow in verifiable outsourced computation},
      howpublished = {Cryptology ePrint Archive, Paper 2014/674},
      year = {2014},
      doi = {10.14722/ndss.2015.23097},
      note = {\url{https://eprint.iacr.org/2014/674}},
      url = {https://eprint.iacr.org/2014/674}
}

@misc{setty19spartan,
      author = {Srinath Setty},
      title = {Spartan: Efficient and general-purpose zkSNARKs without trusted setup},
      howpublished = {Cryptology ePrint Archive, Paper 2019/550},
      year = {2019},
      note = {\url{https://eprint.iacr.org/2019/550}},
      url = {https://eprint.iacr.org/2019/550}
}

@misc{arun23jolt,
      author = {Arasu Arun and Srinath Setty and Justin Thaler},
      title = {Jolt: SNARKs for Virtual Machines via Lookups},
      howpublished = {Cryptology ePrint Archive, Paper 2023/1217},
      year = {2023},
      note = {\url{https://eprint.iacr.org/2023/1217}},
      url = {https://eprint.iacr.org/2023/1217}
}

@misc{setty12ginger,
      author = {Srinath Setty and Victor Vu and Nikhil Panpalia and Benjamin Braun and Muqeet Ali and Andrew J.  Blumberg and Michael Walfish},
      title = {Taking proof-based verified computation a few steps closer to practicality (extended version)},
      howpublished = {Cryptology ePrint Archive, Paper 2012/598},
      year = {2012},
      note = {\url{https://eprint.iacr.org/2012/598}},
      url = {https://eprint.iacr.org/2012/598}
}

@INPROCEEDINGS{kosba18xjsnark,
  author={Kosba, Ahmed and Papamanthou, Charalampos and Shi, Elaine},
  booktitle={2018 IEEE Symposium on Security and Privacy (SP)}, 
  title={xJsnark: A Framework for Efficient Verifiable Computation}, 
  year={2018},
  volume={},
  number={},
  pages={944-961},
  keywords={Logic gates;Optimization;Minimization;Program processors;Programming;Cryptography;Task analysis;Verifiable Computation},
  doi={10.1109/SP.2018.00018}}

  @MastersThesis{lattner02llvm,
    author  = {Chris Lattner},
    title   = "{LLVM: An Infrastructure for Multi-Stage Optimization}",
    school  = "{Computer Science Dept., University of Illinois at Urbana-Champaign}",
    year    = {2002},
    address = {Urbana, IL},
    month   = {Dec},
    note    = {{\em See {\tt http://llvm.cs.uiuc.edu}.}}
  }

@inproceedings{sui16svf,
author = {Sui, Yulei and Xue, Jingling},
title = {SVF: interprocedural static value-flow analysis in LLVM},
year = {2016},
isbn = {9781450342414},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2892208.2892235},
doi = {10.1145/2892208.2892235},
abstract = {This paper presents SVF, a tool that enables scalable and precise interprocedural Static Value-Flow analysis for C programs by leveraging recent advances in sparse analysis. SVF, which is fully implemented in LLVM, allows value-flow construction and pointer analysis to be performed in an iterative manner, thereby providing increasingly improved precision for both. SVF accepts points- to information generated by any pointer analysis (e.g., Andersen’s analysis) and constructs an interprocedural memory SSA form, in which the def-use chains of both top-level and address-taken variables are captured. Such value-flows can be subsequently exploited to support various forms of program analysis or enable more precise pointer analysis (e.g., flow-sensitive analysis) to be performed sparsely. By dividing a pointer analysis into three loosely coupled components: Graph, Rules and Solver, SVF provides an extensible interface for users to write their own solutions easily. SVF is publicly available at http://unsw-corg.github.io/SVF.},
booktitle = {Proceedings of the 25th International Conference on Compiler Construction},
pages = {265–266},
numpages = {2},
keywords = {Pointer Analysis, SVF, Value-Flow},
location = {Barcelona, Spain},
series = {CC 2016}
}

@article{lee18recon,
author = {Lee, Juneyoung and Hur, Chung-Kil and Jung, Ralf and Liu, Zhengyang and Regehr, John and Lopes, Nuno P.},
title = {Reconciling high-level optimizations and low-level code in LLVM},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276495},
doi = {10.1145/3276495},
abstract = {LLVM miscompiles certain programs in C, C++, and Rust that use low-level language features such as raw pointers in Rust or conversion between integers and pointers in C or C++. The problem is that it is difficult for the compiler to implement aggressive, high-level memory optimizations while also respecting the guarantees made by the programming languages to low-level programs. A deeper problem is that the memory model for LLVM's intermediate representation (IR) is informal and the semantics of corner cases are not always clear to all compiler developers. We developed a novel memory model for LLVM IR and formalized it. The new model requires a handful of problematic IR-level optimizations to be removed, but it also supports the addition of new optimizations that were not previously legal. We have implemented the new model and shown that it fixes known memory-model-related miscompilations without impacting the quality of generated code.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {125},
numpages = {28},
keywords = {LLVM, IR Memory Model}
}

@inproceedings{lipton90efficient,
author = {Lipton, Richard J.},
title = {Efficient checking of computations},
year = {1990},
isbn = {0387522824},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the Seventh Annual Symposium on Theoretical Aspects of Computer Science},
pages = {207–215},
numpages = {9},
location = {Rouen, France},
series = {STACS 90}
}

@misc{circ_codebase,
author = {circify},
howpublished = {\url{https://github.com/circify/circ}},
}

@misc{jolt_codebase,
author = {a16z},
howpublished = {\url{https://github.com/a16z/jolt}},
}