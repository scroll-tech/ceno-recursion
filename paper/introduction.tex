\section{Introduction}

A SNARK (succinct non-interactive argument of knowledge) is a cryptographical protocol that allows an untrusted prover $\P$ to convince a verifier $\V$ that it knows a witness $z$ that satisfies certain properties. Trivially, $\P$ can convince $\V$ by sending the entirety of $z$. Through the usage of SNARK, however, $\P$ can produce a proof with shorter length than $z$, and $\V$ can verify the proof faster than reading the entirety of $z$. One popular usage of SNARK is to verify the correct execution of computer programs, which allows users to outsource computations to untrusted parties in cloud computing and blockchain settings.

Early works \cite{setty12ginger, wahby14buffet, kosba18xjsnark, ozdemir20circ} of SNARK primarily focus on program translation. In these \emph{direct-translator} approaches, a program is first converted, in a trusted preprocessing phase, to a set of arithmetic constraints that are satisfiable if and only if the prover $\P$ correctly executes the program. \red{[XXX: Need to emphasize the importance of constraint size.]} Next, $\P$ convinces the verifier $\V$ that it holds an assignment that can satisfy the constraints. Since constraint satisfiability is equivalent to correct program execution, $\V$ accepts the output of the program provided by $\P$. Direct-translators have the advantage of utilizing the semantics and structure of a program to produce the constraints most \emph{tailored} to a specific, which can often lead to massive cost reduction. However, the downside is that the constraints produced need to be \emph{fixed at compile time}, and thus have to take into account all execution paths of the program. In practice, proofs generated by direct-translators need to pay for both branches of a conditional statement, and infer and unroll every loop up to a statically-determined upper bound on number of iterations. These proofs often contain \emph{wastes} -- work that do not correspond to any executed instructions --  increasing compiler, prover, and verifier time.

Later works \cite{zhang18vram, arun23jolt} explore a new type of SNARK focusing on CPU emulation. Commonly referred to as the \emph{virtual machine (VM)} approach, these systems represent any program execution trace with an instruction set architecture (ISA) like TinyRAM or RISC-V assembly, and express correct program execution through correct execution of individual instructions. They achieve so by pre-generating constraints used to verify each instruction in the ISA, and when later given $\P$'s execution trace, map each instruction in the trace to the corresponding constraints. As such a proof contains only instructions executed by $\P$, it avoids wasted work incurred by direct translators. However, since all constraints are pre-generated, \red{[XXX: How to express the idea that constraints NEED to be fixed at compile time?]}, SNARK systems employing the VM approach cannot apply program-specific tailoring, conceding a major advantage to their direct-translator counterparts. Furthermore, these systems often require additional wirings in-between the instructions to ensure consistent program states throughout the execution, introducing additional overheads per instruction.

The advantages and drawbacks of the aforementioned two approaches naturally raise a question: \emph{can a SNARK system emit constraints tailored to each specific program like a direct-translator, while paying only for executed instructions like a VM?} We show an affirmative answer by introducing \CoBBl, a middle path between the direct-translator and VM approaches that absorbs the advantage of both worlds. \CoBBl~makes the following innovations and contributions:
\begin{enumerate}
    \item A SNARK compiler that divides a program into segments and converts each part into constraints.
    \item An optimization toolkit that infers the optimal segmentation of a program, and the optimal constraint representation of each segment.
    \item A proof protocol that specializes in program segment verification, based on Spartan \cite{setty19spartan}.
\end{enumerate}