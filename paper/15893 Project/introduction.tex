\section{Introduction}

A SNARK (succinct non-interactive argument of knowledge) is a cryptographical protocol that allows an untrusted prover $\P$ to convince a verifier $\V$ that it knows a witness $z$ that satisfies some property. Trivially, $\P$ can convince $\V$ by sending the entirety of $z$. However, through the usage of SNARK, $\P$ can produce a proof with shorter length than $z$, and $\V$ can verify the proof faster than reading the entirety of $z$. One popular usage of SNARK is to verify the correct execution of computer programs, which allows users to outsource computations to untrusted parties in cloud computing and blockchain settings.

Early works \cite{setty12ginger, wahby14buffet, kosba18xjsnark, ozdemir20circ} of SNARK predominantly focus on program translation. In these \emph{compiler} approaches, a program is first converted, in a trusted preprocessing phase, to a set of arithmetic constraints that are satisfiable if and only if the prover $\P$ correctly executes the program. Next, $\P$ convinces the verifier $\V$ that it holds an assignment that can satisfy the constraints. Since constraint satisfiability is equivalent to correct program execution, $\V$ accepts the output of the program provided by $\P$. Such compiler approaches are highly optimized, as they can utilize the semantics and structure of the program to produce the most efficient constraints. However, they require the constraints produced to be \emph{fixed at compile time}, which means that they need to take into account all execution paths of the program. In practice, one need convert both branches of a conditional statement into constraints, and unroll every loop up to an inferred or estimated upper bound on number of iterations. Since $\P$ cannot take all branches and loops might break in far fewer iterations than its upper bound, static constraints often lead to "wastes": the proof contains repetitive or unused constraints, increasing compiler, prover, and verifier time.

Recent works \cite{zhang18vram, arun23jolt} explore a new type of SNARK focusing on CPU abstraction. Commonly referred to as the \emph{virtual machine (VM)} approaches, these systems express any program execution using an instruction set architecture (ISA) like TinyRAM or RISC-V assembly, and opt to verify the correct execution of individual instructions. Proofs of these approaches only include instructions executed by $\P$, thus avoiding the "wastes" introduced by earlier works. However, without the presence of a compiler, SNARK systems employing the VM approach often lacks constraint-level optimization. Furthermore, these systems often impose correctness checks on the program states in between the instructions, further introducing overheads per instruction.

The pros and cons of the two approaches above raise a natural question: \emph{can a SNARK system take advantage of the optimizations available to existing SNARK compilers, while enabling the proof to contain dynamic constraints, like the ones in VM approaches?} To answer this question, we introduce \CoBBl, a middle path between the compiler and VM approaches that absorbs the advantage of both worlds. \CoBBl~makes the following innovations and contributions:
\begin{enumerate}
    \item A SNARK compiler that converts a program into a set of constraints, each representing a segment of the program.
    \item An optimization toolkit that can automatically determine the best segmentation of the program, together with the optimal constraint representation of each segment.
    \item A new proof protocol based on Spartan \cite{setty19spartan} that specializes in program segment verification.
\end{enumerate}