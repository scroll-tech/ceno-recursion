from "transcript" import Transcript, append_message_u32, append_message_field
from "tower_struct" import TowerProofs, TowerVerifierOutput
from "mle" import mle_evaluate

def tower_verify(
    field[0][0] initial_prod_evals,
    field[0][0] initial_logup_evals,
    TowerProofs tower_proofs,
    u32 expected_max_round,
    u32 num_fanin,
    Transcript t,
) -> TowerVerifierOutput:
    // XXX to sumcheck batched product argument with logup, we limit num_product_fanin to 2
    // TODO mayber give a better naming?
    assert(num_fanin == 2)
    u32 log2_num_fanin = 1

    // sanity check
    /*
    assert!(initial_prod_evals.len() == tower_proofs.prod_spec_size());
    assert!(
        initial_prod_evals
            .iter()
            .all(|evals| evals.len() == num_fanin)
    );
    assert!(initial_logup_evals.len() == tower_proofs.logup_spec_size());
    assert!(initial_logup_evals.iter().all(|evals| {
        evals.len() == 4 // [p1, p2, q1, q2]
    }));
    */
    u32 initial_prod_evals_len = tower_proofs.prod_spec_size
    u32 initial_logup_evals_len = tower_proofs.logup_spec_size

    // get_challenge_pows
    // decimal expression of "combine subset evals"
    t = append_message_field(t, 567674997755577675492904462386182052033524231283)
    field alpha = t.hash
    arr_decl field[initial_prod_evals_len + initial_logup_evals_len * 2] alpha_rows
    field state = 1
    for u32 i in 0..initial_prod_evals_len + initial_logup_evals_len * 2 do
        alpha_rows[i] = state
        state = state * alpha
    endfor

    arr_decl field[log2_num_fanin] initial_rt
    for u32 i in 0..log2_num_fanin {
        // decimal expression of "product_sum"
        t = append_message_field(t, 135940096403279116418381165)
        initial_rt[i] = t.hash
    }

    // --

    // initial_claim = \sum_j alpha^j * out_j[rt]
    // out_j[rt] := (record_{j}[rt])
    // out_j[rt] := (logup_p{j}[rt])
    // out_j[rt] := (logup_q{j}[rt])
    let initial_claim = izip!(initial_prod_evals, alpha_pows.iter())
        .map(|(evals, alpha)| evals.into_mle().evaluate(&initial_rt) * alpha)
        .sum::<E>()
        + izip!(
            initial_logup_evals,
            alpha_pows[initial_prod_evals_len..].chunks(2)
        )
        .map(|(evals, alpha)| {
            let (alpha_numerator, alpha_denominator) = (&alpha[0], &alpha[1]);
            let (p1, p2, q1, q2) = (evals[0], evals[1], evals[2], evals[3]);
            vec![p1, p2].into_mle().evaluate(&initial_rt) * alpha_numerator
                + vec![q1, q2].into_mle().evaluate(&initial_rt) * alpha_denominator
        })
        .sum::<E>();

    // evaluation in the tower input layer
    let mut prod_spec_input_layer_eval = vec![E::ZERO; tower_proofs.prod_spec_size()];
    let mut logup_spec_p_input_layer_eval = vec![E::ZERO; tower_proofs.logup_spec_size()];
    let mut logup_spec_q_input_layer_eval = vec![E::ZERO; tower_proofs.logup_spec_size()];

    let next_rt = (0..(expected_max_round - 1)).try_fold(
        PointAndEval {
            point: initial_rt,
            eval: initial_claim,
        },
        |point_and_eval, round| {
            let (out_rt, out_claim) = (&point_and_eval.point, &point_and_eval.eval);
            let sumcheck_claim = IOPVerifierState::verify(
                *out_claim,
                &IOPProof {
                    point: vec![], // final claimed point will be derive from sumcheck protocol
                    proofs: tower_proofs.proofs[round].clone(),
                },
                &VPAuxInfo {
                    max_degree: NUM_FANIN + 1, // + 1 for eq
                    num_variables: (round + 1) * log2_num_fanin,
                    phantom: PhantomData,
                },
                transcript,
            );

            // check expected_evaluation
            let rt: Point<E> = sumcheck_claim.point.iter().map(|c| c.elements).collect();
            let expected_evaluation: E = (0..tower_proofs.prod_spec_size())
                .zip(alpha_pows.iter())
                .map(|(spec_index, alpha)| {
                    eq_eval(&out_rt, &rt)
                        * alpha
                        * tower_proofs.prod_specs_eval[spec_index]
                            .get(round)
                            .map(|evals| evals.iter().product())
                            .unwrap_or(E::ZERO)
                })
                .sum::<E>()
                + (0..tower_proofs.logup_spec_size())
                    .zip(alpha_pows[initial_prod_evals_len..].chunks(2))
                    .map(|(spec_index, alpha)| {
                        let (alpha_numerator, alpha_denominator) = (&alpha[0], &alpha[1]);
                        eq_eval(&out_rt, &rt)
                            * tower_proofs.logup_specs_eval[spec_index]
                                .get(round)
                                .map(|evals| {
                                    let (p1, p2, q1, q2) =
                                        (evals[0], evals[1], evals[2], evals[3]);
                                    *alpha_numerator * (p1 * q2 + p2 * q1)
                                        + *alpha_denominator * (q1 * q2)
                                })
                                .unwrap_or(E::ZERO)
                    })
                    .sum::<E>();
            if expected_evaluation != sumcheck_claim.expected_evaluation {
                return Err(ZKVMError::VerifyError("mismatch tower evaluation"));
            }

            // derive single eval
            // rt' = r_merge || rt
            // r_merge.len() == ceil_log2(num_product_fanin)
            let r_merge = (0..log2_num_fanin)
                .map(|_| transcript.get_and_append_challenge(b"merge").elements)
                .collect_vec();
            let coeffs = build_eq_x_r_vec_sequential(&r_merge);
            assert_eq!(coeffs.len(), num_fanin);
            let rt_prime = vec![rt, r_merge].concat();

            let prod_spec_evals = (0..tower_proofs.prod_spec_size())
                .zip(alpha_pows.iter())
                .map(|(spec_index, alpha)| {
                    if round < tower_proofs.prod_specs_eval[spec_index].len() {
                        // merged evaluation
                        let evals = izip!(
                            tower_proofs.prod_specs_eval[spec_index][round].iter(),
                            coeffs.iter()
                        )
                        .map(|(a, b)| *a * b)
                        .sum::<E>();
                        // this will keep update until round > evaluation
                        prod_spec_input_layer_eval[spec_index] = evals;
                        *alpha * evals
                    } else {
                        E::ZERO
                    }
                })
                .sum::<E>();
            let logup_spec_evals = (0..tower_proofs.logup_spec_size())
                .zip(alpha_pows[initial_prod_evals_len..].chunks(2))
                .map(|(spec_index, alpha)| {
                    if round < tower_proofs.logup_specs_eval[spec_index].len() {
                        let (alpha_numerator, alpha_denominator) = (&alpha[0], &alpha[1]);
                        // merged evaluation
                        let p_evals = izip!(
                            tower_proofs.logup_specs_eval[spec_index][round][0..2].iter(),
                            coeffs.iter()
                        )
                        .map(|(a, b)| *a * b)
                        .sum::<E>();

                        let q_evals = izip!(
                            tower_proofs.logup_specs_eval[spec_index][round][2..4].iter(),
                            coeffs.iter()
                        )
                        .map(|(a, b)| *a * b)
                        .sum::<E>();

                        // this will keep update until round > evaluation
                        logup_spec_p_input_layer_eval[spec_index] = p_evals;
                        logup_spec_q_input_layer_eval[spec_index] = q_evals;

                        *alpha_numerator * p_evals + *alpha_denominator * q_evals
                    } else {
                        E::ZERO
                    }
                })
                .sum::<E>();
            // sum evaluation from different specs
            let next_eval = prod_spec_evals + logup_spec_evals;
            Ok(PointAndEval {
                point: rt_prime,
                eval: next_eval,
            })
        },
    )?;

    Ok((
        next_rt.point,
        prod_spec_input_layer_eval,
        logup_spec_p_input_layer_eval,
        logup_spec_q_input_layer_eval,
    ))