from "poseidon_structs" import T, RATE, SparseMDSMatrix, MDSMatrices, OptimizedConstants, Spec, Poseidon

/// Appends elements to the absorption line updates state while `RATE` is
/// full
def update(Poseidon self, u32 elem_len, field[0] elements) -> Poseidon:
    array_decl field[self.absorb_len + elem_len] input_elements
    for u32 i in 0..self.absorb_len do
        input_elements[i] = self.absorbing[i]
    endfor
    for u32 i in 0..elem_len do
        input_elements[self.absorb_len + i] = elements[i]
    endfor

    // Divide input_elements into chunks of length RATE, process all but the last chunk
    u32 num_chunks = (self.absorb_len + elem_len) / RATE
    for u32 i in num_chunks do
        for u32 j in 0..RATE do
            field input_element = input_elements[i * RATE + j]
            field state = self.state[j + 1]
            self.state[j + 1] = state + input_element
        endfor
        // Perform intermediate permutation
        self.spec.permute(&mut self.state);
        // Flush the absorption line
        self.absorbing.clear();
    endfor
    // Record the last chunk in absorbing
    self.absorb_len = self.absorb_len + elem_len - num_chunks * RATE
    array_decl field[self.absorb_len] new_absorbing
    for u32 i in 0..self.absorb_len do
        new_absorbing[i] = input_elements[num_chunks * RATE + i]
    endfor
    self.absorbing = new_absorbing

    return self

/// Results a single element by absorbing already added inputs
pub fn squeeze(&mut self) -> F {
    self.squeeze_vec()[0]
}

/// Results a single element by absorbing already added inputs
pub fn squeeze_vec(&mut self) -> Vec<F> {
    let mut last_chunk = self.absorbing.clone();
    {
        // Expect padding offset to be in [0, RATE)
        debug_assert!(last_chunk.len() < RATE);
    }
    // Add the finishing sign of the variable length hashing. Note that this mut
    // also apply when absorbing line is empty
    last_chunk.push(F::ONE);
    // Add the last chunk of inputs to the state for the final permutation cycle

    for (input_element, state) in last_chunk.iter().zip(self.state.0.iter_mut().skip(1)) {
        state.add_assign(input_element);
    }

    // Perform final permutation
    self.spec.permute(&mut self.state);
    // Flush the absorption line
    self.absorbing.clear();
    // Returns the challenge while preserving internal state
    self.state.results().to_vec()
}