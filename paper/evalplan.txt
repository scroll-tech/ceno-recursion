# Questions we will answer

1. How does CoBBl perform compare to CirC and Jolt, with regard to:
  - Compiler time
  - Prover time
  - Verifier time
2. Comparison on number of constraints:
  - Size of R1CS committed by CoBBl as a percentage of CirC
  - Number of constraints "executed" as a percentage of CirC (due to branches or loop iterations avoided)
  - Size of "extra" constraints (due to check and permutation on execution-ordered trace)
3. Effectiveness of CoBBl optimizations:
  - How does block merge threshold affect the proof? (# of blocks, runtime, etc.)

# To answer question 1
# Baselines
  - CirC (need to switch while loops to for loops)
  - Jolt
  - CoBBl
# Benchmarks
  - Matrix multiplication (u32 & field)
  - Hashing (Sha256 & Poseidon)
  - More if needed
# Metrics
  - Compiler time
  - Prover time
  - Verifier time
# Hypothesis
  - CoBBl should generally beat CirC on any benchmark of significant size (where saving from loops outweighs overhead in permutation)
  - CoBBl should perform on par or slightly worse than Jolt on 32-bit programs (due to lookup table) but significantly better on field computations

# To answer question 2
# Baselines
  - CirC
  - CoBBl using for loops (same code as CirC)
  - CoBBl
# Benchmarks
  - Any of the above?
# Metrics
  - Number of committed constraints
  - Number of executed constraints (# of block constraints * # of block invocation)
  - Number of constraints for permutation and consistency

# To answer question 3
# Baselines
  - CoBBl with different merge thresholds
  - (Maybe tests on spilling? Although that likely won't be significant)
# Metrics
  - Number of committed & executed constraints
  - Total size of transition state
# Hypothesis
  - There should be a "sweet spot" for each benchmark
  - Finding the precise "sweet spot" might be future work

# Discussions / Limitations
- Without the usage of lookup tables, it might be difficult to match Jolt on 32-bit operations. Incorporating lookup tables can be of a future work.
- Efficiency of CoBBl relies on effective compiler analysis. Future work can be done to find "the optimal" circuit representation for each benchmark. 

Evaluation for Compact Certificate
1. Comparing CoBBl with CirC and Jolt
  - The comparison _should_ show CoBBl beat CirC and Jolt in both compiler and prover time (maybe run CirC and Jolt till the highest number of reveals possible?)
2. Comparing CoBBl proof with the original compact certificate
  - A graph depicting CoBBl and CC size of fixed # of attestors based on % of verified signers
3. Exploration of other commitment scheme
  - Potentially a pseudo HyperBKG implementation to further reduce proof size