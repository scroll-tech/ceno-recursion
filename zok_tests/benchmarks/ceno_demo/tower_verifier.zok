from "transcript" import Transcript, append_message_u32, append_message_field
from "sumcheck_structs" import IOPProverMessage, SumcheckProof, VPAuxInfo, SumCheckSubClaim, SumcheckIOPVerifierState
from "sumcheck_verifier" import verify_round_and_update_state, interpolate_uni_poly, check_and_generate_subclaim, verify_sumcheck
from "mle" import mle_evaluate
from "tower_struct" import TowerProofs, TowerVerifierOutput, PointAndEval

def tower_verify(
    field[0][0] initial_prod_evals,
    field[0][0] initial_logup_evals,
    TowerProofs tower_proofs,
    u32 expected_max_round,
    u32 num_fanin,
    u32 log2_num_fanin,
    Transcript t
) -> TowerVerifierOutput:
    // XXX to sumcheck batched product argument with logup, we limit num_product_fanin to 2
    // TODO mayber give a better naming?
    assert(num_fanin == 2)
    assert(log2_num_fanin == 1)

    // sanity check
    /*
    assert!(initial_prod_evals.len() == tower_proofs.prod_spec_size());
    assert!(
        initial_prod_evals
            .iter()
            .all(|evals| evals.len() == num_fanin)
    );
    assert!(initial_logup_evals.len() == tower_proofs.logup_spec_size());
    assert!(initial_logup_evals.iter().all(|evals| {
        evals.len() == 4 // [p1, p2, q1, q2]
    }));
    */
    u32 initial_prod_evals_len = tower_proofs.prod_spec_size
    u32 initial_logup_evals_len = tower_proofs.logup_spec_size

    // get_challenge_pows
    // decimal expression of "combine subset evals"
    
    t = append_message_field(t, 567674997755577675492904462386182052033524231283)
    /* --
    // field alpha = t.hash
    */

    field alpha = 1
    array_decl field[initial_prod_evals_len + initial_logup_evals_len * 2] alpha_rows
    field state = 1
    for u32 i in 0..initial_prod_evals_len + initial_logup_evals_len * 2 do
        alpha_rows[i] = state
        state = state * alpha
    endfor

    array_decl field[log2_num_fanin] initial_rt
    for u32 i in 0..log2_num_fanin do
        // decimal expression of "product_sum"
        t = append_message_field(t, 135940096403279116418381165)
        /* --
        // initial_rt[i] = t.hash
        */
        initial_rt[i] = 0
    endfor

    // --

    // initial_claim = \sum_j alpha^j * out_j[rt]
    // out_j[rt] := (record_{j}[rt])
    // out_j[rt] := (logup_p{j}[rt])
    // out_j[rt] := (logup_q{j}[rt])
    field initial_claim = 0
    for u32 i in 0..initial_prod_evals_len do
        field[0] evals = initial_prod_evals[i]
        field alpha = alpha_rows[i]
        initial_claim = initial_claim + mle_evaluate(evals, num_fanin, initial_rt, log2_num_fanin) * alpha
    endfor
    for u32 i in 0..initial_logup_evals_len do
        field alpha_numerator = alpha_rows[initial_prod_evals_len + 2 * i]
        field alpha_denominator = alpha_rows[initial_prod_evals_len + 2 * i + 1]
        field[2] mle_numerator = [initial_logup_evals[i][0], initial_logup_evals[i][1]]
        field[2] mle_denominator = [initial_logup_evals[i][2], initial_logup_evals[i][3]]
        initial_claim = initial_claim + mle_evaluate(mle_numerator, num_fanin, initial_rt, log2_num_fanin) * alpha_numerator
        initial_claim = initial_claim + mle_evaluate(mle_denominator, num_fanin, initial_rt, log2_num_fanin) * alpha_denominator
    endfor

    // evaluation in the tower input layer
    field[tower_proofs.prod_spec_size] prod_spec_input_layer_eval = [0; tower_proofs.prod_spec_size]
    field[tower_proofs.logup_spec_size] logup_spec_p_input_layer_eval = [0; tower_proofs.logup_spec_size]
    field[tower_proofs.logup_spec_size] logup_spec_q_input_layer_eval = [0; tower_proofs.logup_spec_size]

    PointAndEval next_rt = PointAndEval {
        point: initial_rt,
        eval: initial_claim
    }
    for u32 round in 0..expected_max_round - 1 do
        field[0] out_rt = next_rt.point
        field out_claim = next_rt.eval
        SumCheckSubClaim sumcheck_claim = verify_sumcheck(
            out_claim,
            SumcheckProof {
                points: [], // final claimed point will be derive from sumcheck protocol
                proofs: tower_proofs.proofs[round]
            },
            VPAuxInfo {
                max_degree: num_fanin + 1, // + 1 for eq
                num_variables: (round + 1) * log2_num_fanin
            },
            t
        )

        // check expected_evaluation
    endfor

    /*
    let next_rt = (0..(expected_max_round - 1)).try_fold(
        PointAndEval {
            point: initial_rt,
            eval: initial_claim,
        },
        |point_and_eval, round| {
            let (out_rt, out_claim) = (&point_and_eval.point, &point_and_eval.eval);
            let sumcheck_claim = IOPVerifierState::verify(
                *out_claim,
                &IOPProof {
                    point: vec![], // final claimed point will be derive from sumcheck protocol
                    proofs: tower_proofs.proofs[round].clone(),
                },
                &VPAuxInfo {
                    max_degree: NUM_FANIN + 1, // + 1 for eq
                    num_variables: (round + 1) * log2_num_fanin,
                    phantom: PhantomData,
                },
                transcript,
            );

            // check expected_evaluation
            let rt: Point<E> = sumcheck_claim.point.iter().map(|c| c.elements).collect();
            let expected_evaluation: E = (0..tower_proofs.prod_spec_size())
                .zip(alpha_pows.iter())
                .map(|(spec_index, alpha)| {
                    eq_eval(&out_rt, &rt)
                        * alpha
                        * tower_proofs.prod_specs_eval[spec_index]
                            .get(round)
                            .map(|evals| evals.iter().product())
                            .unwrap_or(E::ZERO)
                })
                .sum::<E>()
                + (0..tower_proofs.logup_spec_size())
                    .zip(alpha_pows[initial_prod_evals_len..].chunks(2))
                    .map(|(spec_index, alpha)| {
                        let (alpha_numerator, alpha_denominator) = (&alpha[0], &alpha[1]);
                        eq_eval(&out_rt, &rt)
                            * tower_proofs.logup_specs_eval[spec_index]
                                .get(round)
                                .map(|evals| {
                                    let (p1, p2, q1, q2) =
                                        (evals[0], evals[1], evals[2], evals[3]);
                                    *alpha_numerator * (p1 * q2 + p2 * q1)
                                        + *alpha_denominator * (q1 * q2)
                                })
                                .unwrap_or(E::ZERO)
                    })
                    .sum::<E>();
            if expected_evaluation != sumcheck_claim.expected_evaluation {
                return Err(ZKVMError::VerifyError("mismatch tower evaluation"));
            }

            // derive single eval
            // rt' = r_merge || rt
            // r_merge.len() == ceil_log2(num_product_fanin)
            let r_merge = (0..log2_num_fanin)
                .map(|_| transcript.get_and_append_challenge(b"merge").elements)
                .collect_vec();
            let coeffs = build_eq_x_r_vec_sequential(&r_merge);
            assert_eq!(coeffs.len(), num_fanin);
            let rt_prime = vec![rt, r_merge].concat();

            let prod_spec_evals = (0..tower_proofs.prod_spec_size())
                .zip(alpha_pows.iter())
                .map(|(spec_index, alpha)| {
                    if round < tower_proofs.prod_specs_eval[spec_index].len() {
                        // merged evaluation
                        let evals = izip!(
                            tower_proofs.prod_specs_eval[spec_index][round].iter(),
                            coeffs.iter()
                        )
                        .map(|(a, b)| *a * b)
                        .sum::<E>();
                        // this will keep update until round > evaluation
                        prod_spec_input_layer_eval[spec_index] = evals;
                        *alpha * evals
                    } else {
                        E::ZERO
                    }
                })
                .sum::<E>();
            let logup_spec_evals = (0..tower_proofs.logup_spec_size())
                .zip(alpha_pows[initial_prod_evals_len..].chunks(2))
                .map(|(spec_index, alpha)| {
                    if round < tower_proofs.logup_specs_eval[spec_index].len() {
                        let (alpha_numerator, alpha_denominator) = (&alpha[0], &alpha[1]);
                        // merged evaluation
                        let p_evals = izip!(
                            tower_proofs.logup_specs_eval[spec_index][round][0..2].iter(),
                            coeffs.iter()
                        )
                        .map(|(a, b)| *a * b)
                        .sum::<E>();

                        let q_evals = izip!(
                            tower_proofs.logup_specs_eval[spec_index][round][2..4].iter(),
                            coeffs.iter()
                        )
                        .map(|(a, b)| *a * b)
                        .sum::<E>();

                        // this will keep update until round > evaluation
                        logup_spec_p_input_layer_eval[spec_index] = p_evals;
                        logup_spec_q_input_layer_eval[spec_index] = q_evals;

                        *alpha_numerator * p_evals + *alpha_denominator * q_evals
                    } else {
                        E::ZERO
                    }
                })
                .sum::<E>();
            // sum evaluation from different specs
            let next_eval = prod_spec_evals + logup_spec_evals;
            Ok(PointAndEval {
                point: rt_prime,
                eval: next_eval,
            })
        },
    )?;
    */

    return TowerVerifierOutput {
        rt_tower: next_rt.point,
        record_evals: prod_spec_input_layer_eval,
        logup_p_evals: logup_spec_p_input_layer_eval,
        logup_q_evals: logup_spec_q_input_layer_eval
    }

def main() -> u32:
    field[1][2] initial_prod_evals = [[1, 0]]
    field[1][2] initial_logup_evals = [[1, 2, 1, 2]]
    TowerProofs tower_proofs = TowerProofs {
        prod_spec_size: 1,
        logup_spec_size: 1,
         proofs: [[IOPProverMessage {
            evaluations: [1, 2, 3]
        }; 3]],
        prod_specs_eval: [],
        logup_specs_eval: []
    }
    u32 expected_max_round = 2
    u32 num_fanin = 2
    u32 log2_num_fanin = 1
    Transcript t = Transcript {
        hash: 0
    }
    TowerVerifierOutput output = tower_verify(initial_prod_evals, initial_logup_evals, tower_proofs, expected_max_round, num_fanin, log2_num_fanin, t)

    return 1