from "transcript" import Transcript, append_message_u32, append_message_field
from "gkr_structs" import PointAndEval, LayeredPointAndEval, GkrIOPVerifierState, Layer, Circuit, IOPProverStepMessage, IOPProof, GkrInputClaims
from "gkr_structs" import OutputPhase1Step1, OutputPhase1Step2, Phase1Step1, Phase2Step1, Phase2Step2, Phase2Step2NoStep3, Phase2Step3, LinearPhase2Step1, InputPhase2Step1, Undefined
from "phase1" import verify_and_update_state_phase1_step1

/// Initialize verifying state for data parallel circuits.
def verifier_init_parallel(
    u32 d, // size of a point
    u32 n_layers,
    field[0][0] challenges,
    u32 output_len,
    PointAndEval[0] output_evals,
    u32 wires_len,
    PointAndEval[0] wires_out_evals,
    u32 instance_num_vars,
    Transcript t,
    u32 output_wit_num_vars
) -> GkrIOPVerifierState:
    u32[n_layers] subset_point_and_evals_len = [0; n_layers]
    array_decl LayeredPointAndEval[n_layers][0] subset_point_and_evals
    PointAndEval to_next_step_point_and_eval = PointAndEval {
        d: 0,
        point: [],
        eval: 0
    }
    if output_len == 0 then
        to_next_step_point_and_eval = wires_out_evals[wires_len - 1]
    else
        to_next_step_point_and_eval = output_evals[output_len - 1]
    endif
    array_decl field[output_wit_num_vars] assert_point
    for u32 i in 0..output_wit_num_vars do
        // Decimal representation of "assert_point"
        t = append_message_field(t, 30159617365440157229391638132)
        assert_point[i] = t.hash
    endfor
    u32 to_next_phase_point_and_evals_len = output_len
    PointAndEval[output_len] to_next_phase_point_and_evals = output_evals
    
    // subset_point_and_evals[0] <- wires_out_evals.into_iter().map(|p| (0, p)).collect()
    array_decl LayeredPointAndEval[wires_len] subset_point_and_evals_0
    for u32 i in 0..wires_len do
        LayeredPointAndEval entry = LayeredPointAndEval {
            layer_id: 0,
            point_and_eval: wires_out_evals[i]
        }
        subset_point_and_evals_0[i] = entry
    endfor
    subset_point_and_evals[0] = subset_point_and_evals_0

    return GkrIOPVerifierState {
        to_next_phase_point_and_evals_len: to_next_phase_point_and_evals_len,
        to_next_phase_point_and_evals: to_next_phase_point_and_evals,
        subset_point_and_evals_len: subset_point_and_evals_len,
        subset_point_and_evals: subset_point_and_evals,
        to_next_step_point_and_eval: to_next_step_point_and_eval,

        challenges: challenges,
        instance_num_vars: instance_num_vars,

        assert_point: assert_point,
        // Default
        layer_id: 0,
        g1_values: [],
        out_point: [],
        eq_y_ry: [],
        eq_x1_rx1: [],
        eq_x2_rx2: [],
    }

def verify_parallel(
    u32 d, // size of a point
    Circuit circuit,
    field[0][0] challenges,
    u32 output_len,
    PointAndEval[0] output_evals,
    u32 wires_len,
    PointAndEval[0] wires_out_evals,
    IOPProof proof,
    u32 instance_num_vars,
    Transcript t
) -> GkrInputClaims:
    // let challenges = circuit.generate_basefield_challenges(challenges);

    GkrIOPVerifierState verifier_state = verifier_init_parallel(
        d,
        circuit.num_layers,
        challenges,
        output_len,
        output_evals,
        wires_len,
        wires_out_evals,
        instance_num_vars,
        t,
        circuit.layers[0].num_vars + instance_num_vars
    )

    for u32 layer_id in 0..circuit.num_layers do
        verifier_state.layer_id = layer_id

        Layer layer = circuit.layers[layer_id]
        for u32 i in 0..layer.num_sumcheck_steps do
            field step = layer.sumcheck_steps[i]
            IOPProverStepMessage step_proof = proof.sumcheck_proofs[i]
            if step == Phase1Step1 then
                assert(verify_and_update_state_phase1_step1(verifier_state, circuit, step_proof, t))
            endif
            /*
            match step {
                SumcheckStepType::OutputPhase1Step1 => verifier_state
                    .verify_and_update_state_output_phase1_step1(
                        circuit, step_proof, transcript,
                    )?,
                SumcheckStepType::OutputPhase1Step2 => verifier_state
                    .verify_and_update_state_output_phase1_step2(
                        circuit, step_proof, transcript,
                    )?,
                SumcheckStepType::Phase1Step1 => verifier_state
                    .verify_and_update_state_phase1_step1(circuit, step_proof, transcript)?,
                SumcheckStepType::Phase2Step1 => verifier_state
                    .verify_and_update_state_phase2_step1(circuit, step_proof, transcript)?,
                SumcheckStepType::Phase2Step2 => verifier_state
                    .verify_and_update_state_phase2_step2(
                        circuit, step_proof, transcript, false,
                    )?,
                SumcheckStepType::Phase2Step2NoStep3 => verifier_state
                    .verify_and_update_state_phase2_step2(
                        circuit, step_proof, transcript, true,
                    )?,
                SumcheckStepType::Phase2Step3 => verifier_state
                    .verify_and_update_state_phase2_step3(circuit, step_proof, transcript)?,
                SumcheckStepType::LinearPhase2Step1 => verifier_state
                    .verify_and_update_state_linear_phase2_step1(
                        circuit, step_proof, transcript,
                    )?,
                SumcheckStepType::InputPhase2Step1 => verifier_state
                    .verify_and_update_state_input_phase2_step1(
                        circuit, step_proof, transcript,
                    )?,
                _ => unreachable!(),
            }
            */
        endfor
    endfor


    return GkrInputClaims {
        point_and_evals: verifier_state.to_next_phase_point_and_evals,
    }