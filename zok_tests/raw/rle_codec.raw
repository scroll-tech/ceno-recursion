CONST:
max_n 100

INPUT:
x 0
y 0

PROGRAM:
def compress(u32 n, u32[{max_n}] txt, u32[{max_n + max_n}] compr) -> u32:
    // worst case is no compression, in which case we actually double
    // the size of the string!  Note that we could avoid this with a
    // different encoding strategy, but for our purposes the *performance*
    // of the two strategies is little different, and no one is sweating
    // our Weissman Score here. ;)
    u32 next_c = 0
    u32 next_t = 0
    u32 next_data = txt[0]
    u32 next_count = 0

    // BASELINE
    for u32 counter in 0..{max_n + max_n} do
        if next_t < n then
            if txt[next_t] == next_data then
                next_count = next_count + 1
            else
                compr[next_c] = next_data
                compr[next_c + 1] = next_count
                next_c = next_c + 2
                next_data = txt[next_t]
                next_count = 1
            endif
            next_t = next_t + 1
        endif
    endfor

    // COBBL
    while next_t < n do
        if txt[next_t] == next_data then
            next_count = next_count + 1
        else
            compr[next_c] = next_data
            compr[next_c + 1] = next_count
            next_c = next_c + 2
            next_data = txt[next_t]
            next_count = 1
        endif
        next_t = next_t + 1
    endwhile

    // END_SPLIT

    // write out the last one
    compr[next_c] = next_data
    compr[next_c + 1] = next_count
    next_c = next_c + 2
    
    return next_c

def decompress(u32 m, u32[{max_n + max_n}] compr, u32[{max_n}] out) -> u32:
    u32 next_c = 0
    u32 next_t = 0

    // BASELINE
    // Use state machine
    u32 next_data = 0
    u32 next_count = 0
    u32 state = 0
    for u32 counter in 0..{max_n} do
        if next_c < m then
            if state == 0 then
                next_data = compr[next_c]
                next_count = compr[next_c + 1]
                state = next_count > 0 ? 1 : 2
            endif
            if state == 1 then
                out[next_t] = next_data
                next_t = next_t + 1
                next_count = next_count - 1
                state = next_count > 0 ? 1 : 2
            endif
            if state == 2 then
                next_c = next_c + 2
                state = 0
            endif
        endif
    endfor

    // COBBL
    while next_c < m do
        u32 next_data = compr[next_c]
        u32 next_count = compr[next_c + 1]
        while next_count > 0 do
            out[next_t] = next_data
            next_t = next_t + 1
            next_count = next_count - 1
        endwhile
        next_c = next_c + 2
    endwhile
    
    // END_SPLIT

    return next_t

def main(u32 x, u32 y, u32 n) -> u32:
    u32[{max_n}] txt = [0; {max_n}]

    // Initialize array
    u32 next_gap = 1
    u32 gap = next_gap
    for u32 i in 0..{max_n} do
        txt[i] = next_gap
        gap = gap - 1
        if gap == 0 then
            next_gap = next_gap + 1
            gap = next_gap
        endif
    endfor

    // compress
    u32[{max_n + max_n}] compr = [0; {max_n + max_n}]
    u32 m = compress(n, txt, compr)

    // decompress
    u32[{max_n}] out = [0; {max_n}]
    u32 p = decompress(m, compr, out)

    assert(n == p)
    // BASELINE
    for u32 i in 0..{max_n} do
        if i < n then
            assert(txt[i] == out[i])
            i = i + 1
        endif
    endfor

    // COBBL
    u32 i = 0
    while i < n do
        assert(txt[i] == out[i])
        i = i + 1
    endwhile
    // END_SPLIT

    return (txt[x] + compr[x] + out[x]) * y 