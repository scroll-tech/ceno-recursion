from "transcript" import Transcript, append_message_u32, append_message_field
from "gkr_structs" import PointAndEval, LayeredPointAndEval, GkrIOPVerifierState

/// Initialize verifying state for data parallel circuits.
def verifier_init_parallel(
    u32 d, // size of a point
    u32 n_layers,
    field[0][0] challenges,
    u32 output_len,
    PointAndEval[0] output_evals,
    u32 wires_len,
    PointAndEval[0] wires_out_evals,
    u32 instance_num_vars,
    Transcript t,
    u32 output_wit_num_vars
) -> u32:
    array_decl LayeredPointAndEval[n_layers][0] subset_point_and_evals
    PointAndEval to_next_step_point_and_eval = output_len == 0 ? wires_out_evals[wires_len - 1] : output_evals[output_len - 1]
    array_decl field[output_wit_num_vars] assert_point
    for u32 i in 0..output_wit_num_vars do
        // Decimal representation of "assert_point"
        t = append_message_field(t, 30159617365440157229391638132)
        assert_point[i] = t.hash
    endfor
    PointAndEval[output_len] to_next_phase_point_and_evals = output_evals
    
    // subset_point_and_evals[0] <- wires_out_evals.into_iter().map(|p| (0, p)).collect()
    array_decl LayeredPointAndEval[wires_len] subset_point_and_evals_0
    for u32 i in 0..wires_len do
        LayeredPointAndEval entry = LayeredPointAndEval {
            layer_id: 0,
            point_and_eval: wires_out_evals[i]
        }
        subset_point_and_evals_0[i] = entry
    endfor
    subset_point_and_evals[0] = subset_point_and_evals_0

    return GkrIOPVerifierState {
        to_next_phase_point_and_evals: to_next_phase_point_and_evals,
        subset_point_and_evals: subset_point_and_evals,
        to_next_step_point_and_eval: to_next_step_point_and_eval,

        challenges: challenges,
        instance_num_vars: instance_num_vars,

        assert_point: assert_point,
        // Default
        layer_id: 0,
        g1_values: [],
        out_point: [],
        eq_y_ry: [],
        eq_x1_rx1: [],
        eq_x2_rx2: [],
    }
    return 1