\section{Preliminaries}
To present the general framework in which \CoBBl~operates, we begin with a few building blocks and general definitions.

\paragraph{SNARK} SNARK (succinct non-interactive argument of knowledge) is a cryptographical protocol in between two parties: a prover $\P$ and a verifier $\V$. The input of the protocol is a set of constraints $\C$, to which $\P$ purportedly holds a satisfying assignment $z$. The protocol itself involves $\P$ utilizing a randomized algorithm to generate a proof of knowledge, which $\V$ can apply the same randomness to verify in time sublinear to the size of $\C$.

\paragraph{Verifiable Computation (VC)} In a VC setting, a verifier $\V$ outsources a computation $f(x)$ to an untrusted prover $\P$. $\P$ returns the purported output $y\xleftarrow{?} f(x)$ together with a SNARK proof $\pi$ on the correctness of $y$. $\V$ checks the proof and either accepts or rejects $y$. In particular, the above protocol needs to satisfy three requirements:
\begin{itemize}
    \item \textbf{Completeness}: If $y=f(x)$, then $\V$ always accepts $y$.
    \item \textbf{Soundness}: If $y\neq f(x)$, then $\V$ rejects $y$ except for negligible probability.
    \item \textbf{Succinctness}: The size of $\pi$ and $\V$'s work should be sublinear to the execution of $f(x)$.
\end{itemize}

\paragraph{Frontend and Backend} SNARK systems are usually divided into two phases: the frontend that generates constraints, and a backend that generates proofs from the constraints. The frontend of compiler-style and VM-style SNARKs are substantially different. However, since these frontends ultimately all emits arithmetic constraints, different SNARK systems can share the same backend.

\paragraph{Data-Parallelism} Many SNARK backend systems support data-parallelism, which verifies multiple SNARK proofs at once, with time sublinear to sequential verification. Data-parallelism usually requires the proofs to share some common properties like number of constraints and witnesses.

\paragraph{Basic Blocks (BB)} A basic block is a sequence of code in a program that contains no control flow in-between. In other words, the execution of the first instruction in a BB implies the execution of every instruction in that BB. BBs are frequently used by compilers as the basis for analyses and optimizations, and a program can be expressed as a control flow graph of its BBs.