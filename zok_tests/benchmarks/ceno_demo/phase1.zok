from "transcript" import Transcript, append_message_u32, append_message_field
from "gkr_structs" import PointAndEval, LayeredPointAndEval, GkrIOPVerifierState, Layer, Circuit, IOPProverStepMessage, IOPProof, GKRInputClaims
from "sumcheck_structs" import SumcheckProof, VPAuxInfo, SumCheckSubClaim
from "sumcheck_verifier" import verify_sumcheck

def verify_and_update_state_phase1_step1(
    GkrIOPVerifierState self,
    Circuit circuit,
    IOPProverStepMessage step_msg,
    Transcript t
) -> bool:
    // Decimal representation of "combine subset evals"
    t = append_message_field(t, 567674997755577675492904462386182052033524231283)
    field alpha = t.hash
    u32 total_length = self.to_next_phase_point_and_evals_len + self.subset_point_and_evals_len[self.layer_id] + 1

    field[total_length] alpha_pows = [1; total_length]
    for u32 i in 0..total_length - 1 do
        alpha_pows[i + 1] = alpha_pows[i] * alpha
    endfor

    u32 lo_num_vars = circuit.layers[self.layer_id].num_vars
    u32 hi_num_vars = self.instance_num_vars

    // sigma = \sum_j( \alpha^j * subset[i][j](rt_j || ry_j) )
    field sigma_1 = 0
    for u32 i in 0..self.to_next_phase_point_and_evals_len do
        sigma_1 = sigma_1 + self.to_next_phase_point_and_evals[i].eval * alpha_pows[i]
    endfor
    for u32 i in 0..self.subset_point_and_evals_len[self.layer_id] do
        sigma_1 = sigma_1 + self.subset_point_and_evals[self.layer_id][i].point_and_eval.eval * alpha_pows[i + self.to_next_phase_point_and_evals_len]
    endfor

    // Sumcheck: sigma = \sum_{t || y}(f1({t || y}) * (\sum_j g1^{(j)}({t || y})))
    // f1^{(j)}(y) = layers[i](t || y)
    // g1^{(j)}(t || y) = \alpha^j * eq(rt_j, t) * eq(ry_j, y)
    // g1^{(j)}(t || y) = \alpha^j * eq(rt_j, t) * copy_to[j](ry_j, y)
    SumCheckSubClaim claim_1 = verify_sumcheck(
        sigma_1,
        step_msg.sumcheck_proof,
        VPAuxInfo {
            max_degree: 2,
            num_variables: lo_num_vars + hi_num_vars,
        },
        t
    )

    /*
    let claim1_point = claim_1.point.iter().map(|x| x.elements).collect_vec();
    let claim1_point_lo_num_vars = claim1_point.len() - hi_num_vars;
    let eq_y_ry = build_eq_x_r_vec(&claim1_point[..claim1_point_lo_num_vars]);

    assert_eq!(step_msg.sumcheck_eval_values.len(), 1);
    let f_value = step_msg.sumcheck_eval_values[0];

    let g_value: E = chain![
        izip!(self.to_next_phase_point_and_evals.iter(), alpha_pows.iter()).map(
            |(point_and_eval, alpha_pow)| {
                let point_lo_num_vars = point_and_eval.point.len() - hi_num_vars;
                let eq_t = eq_eval(
                    &point_and_eval.point[point_lo_num_vars..],
                    &claim1_point[(claim1_point.len() - hi_num_vars)..],
                );
                let eq_y = eq_eval(
                    &point_and_eval.point[..point_lo_num_vars],
                    &claim1_point[..point_lo_num_vars],
                );
                eq_t * eq_y * alpha_pow
            }
        ),
        izip!(
            self.subset_point_and_evals[self.layer_id as usize].iter(),
            alpha_pows
                .iter()
                .skip(self.to_next_phase_point_and_evals.len())
        )
        .map(|((new_layer_id, point_and_eval), alpha_pow)| {
            let point_lo_num_vars = point_and_eval.point.len() - hi_num_vars;
            let eq_t = eq_eval(
                &point_and_eval.point[point_lo_num_vars..],
                &claim1_point[(claim1_point.len() - hi_num_vars)..],
            );
            let eq_yj_ryj = build_eq_x_r_vec(&point_and_eval.point[..point_lo_num_vars]);
            eq_t * circuit.layers[self.layer_id as usize].copy_to[new_layer_id]
                .as_slice()
                .eval_row_first(&eq_yj_ryj, &eq_y_ry)
                * alpha_pow
        }),
    ]
    .sum();

    let got_value = f_value * g_value;

    if claim_1.expected_evaluation != got_value {
        return Err(GKRError::VerifyError("phase1 step1 failed"));
    }
    self.to_next_step_point_and_eval = PointAndEval::new_from_ref(&claim1_point, &f_value);
    self.to_next_phase_point_and_evals = vec![self.to_next_step_point_and_eval.clone()];

    self.subset_point_and_evals[self.layer_id as usize].clear();
    */

    return true