from "transcript" import Transcript, TranscriptAndChallenge, TranscriptAndChallengePows, new_transcript, append_message, append_field_element_ext, get_and_append_challenge, read_challenge, get_challenge_pows
from "sumcheck_structs" import IOPProverMessage, SumcheckProof, VPAuxInfo, SumCheckSubClaim, SumcheckIOPVerifierState, SumCheckSubClaimAndTranscript
from "sumcheck_verifier" import verify_round_and_update_state, interpolate_uni_poly, check_and_generate_subclaim, verify_sumcheck
from "mle" import mle_eval, eq_eval, build_eq_x_r_vec_sequential
from "tower_struct" import TowerProofs, TowerVerifierOutput, PointAndEval

const u32 num_fanin = 2
const u32 log2_num_fanin = 1

def tower_verify(
    ExtField[0][0] initial_prod_evals,
    ExtField[0][0] initial_logup_evals,
    TowerProofs tower_proofs,
    u32 expected_max_round,
    Transcript t
) -> TowerVerifierOutput:
    // XXX to sumcheck batched product argument with logup, we limit num_product_fanin to 2
    // TODO mayber give a better naming?
    // assert(num_fanin == 2)

    // sanity check
    /*
    assert!(initial_prod_evals.len() == tower_proofs.prod_spec_size());
    assert!(
        initial_prod_evals
            .iter()
            .all(|evals| evals.len() == num_fanin)
    );
    assert!(initial_logup_evals.len() == tower_proofs.logup_spec_size());
    assert!(initial_logup_evals.iter().all(|evals| {
        evals.len() == 4 // [p1, p2, q1, q2]
    }));
    */
    u32 initial_prod_evals_len = tower_proofs.prod_spec_size
    u32 initial_logup_evals_len = tower_proofs.logup_spec_size

    TranscriptAndChallengePows t_cp = get_challenge_pows(num_prod_spec + num_logup_spec * 2, t);
    transcript = t_cp.transcript
    ExtField[0] alpha_pows = t_cp.challenge_pows

    array_decl ExtField[log2_num_fanin] initial_rt
    for u32 i in 0..log2_num_fanin do
        TranscriptAndChallenge t0 = get_and_append_challenge(t, 2, [6878231886748938864, 7173491]) // b"product_sum"
        t = t0.transcript
        initial_rt[i] = t0.challenge.elements
    endfor

    // --

    // initial_claim = \sum_j alpha^j * out_j[rt]
    // out_j[rt] := (record_{j}[rt])
    // out_j[rt] := (logup_p{j}[rt])
    // out_j[rt] := (logup_q{j}[rt])
    field initial_claim = 0
    for u32 i in 0..initial_prod_evals_len do
        ExtField[0] evals = initial_prod_evals[i]
        ExtField alpha = alpha_pows[i]
        initial_claim = initial_claim + mle_eval(evals, num_fanin, initial_rt, log2_num_fanin) * alpha
    endfor
    for u32 i in 0..initial_logup_evals_len do
        ExtField alpha_numerator = alpha_pows[initial_prod_evals_len + 2 * i]
        ExtField alpha_denominator = alpha_pows[initial_prod_evals_len + 2 * i + 1]
        ExtField[2] mle_numerator = [initial_logup_evals[i][0], initial_logup_evals[i][1]]
        ExtField[2] mle_denominator = [initial_logup_evals[i][2], initial_logup_evals[i][3]]
        initial_claim = initial_claim + mle_eval(mle_numerator, num_fanin, initial_rt, log2_num_fanin) * alpha_numerator
        initial_claim = initial_claim + mle_eval(mle_denominator, num_fanin, initial_rt, log2_num_fanin) * alpha_denominator
    endfor

    // evaluation in the tower input layer
    array_decl ExtField[tower_proofs.prod_spec_size] prod_spec_input_layer_eval
    array_decl ExtField[tower_proofs.logup_spec_size] logup_spec_p_input_layer_eval
    array_decl ExtField[tower_proofs.logup_spec_size] logup_spec_q_input_layer_eval

    PointAndEval next_rt = PointAndEval {
        point: initial_rt,
        eval: initial_claim
    }
    u32 eval_len = 1
    for u32 round in 0..expected_max_round - 1 do
        ExtField[0] out_rt = next_rt.point
        ExtField out_claim = next_rt.eval
        u32 rt_len = (round + 1) * log2_num_fanin
        // FOLDED verify_sumcheck
        SumCheckSubClaimAndTranscript sc_t = verify_sumcheck(
            out_claim,
            SumcheckProof {
                points: [], // final claimed point will be derive from sumcheck protocol
                proofs: tower_proofs.proofs[round]
            },
            VPAuxInfo {
                max_degree: num_fanin + 1, // + 1 for eq
                num_variables: rt_len
            },
            t
        )
        SumCheckSubClaim sumcheck_claim = sc_t.sc
        t = sc_t.t

        // check expected_evaluation
        array_decl ExtField[rt_len] rt
        for u32 i in 0..rt_len do
            rt[i] = sumcheck_claim.point[i].elements
        endfor
        ExtField expected_evaluation = to_ext(0)
        for u32 spec_index in 0..tower_proofs.prod_spec_size do
            if tower_proofs.layer_per_spec[spec_index] < round then
                ExtField alpha = alpha_pows[spec_index]
                ExtField prod = to_ext(1)
                for u32 i in 0..eval_len do
                    prod = ext_mul(prod, tower_proofs.prod_specs_eval[spec_index][round][i])
                endfor
                // expected_evaluation = expected_evaluation + eq_eval(rt_len, out_rt, rt) * alpha * prod
                expected_evaluation = ext_add(expected_evaluation, ext_mul(ext_mul(eq_eval(rt_len, out_rt, rt), alpha), prod))
            endif
        endfor
        for u32 spec_index in 0..tower_proofs.logup_spec_size do
            if tower_proofs.layer_per_spec[spec_index] < round then
                ExtField alpha_numerator = alpha_pows[initial_prod_evals_len + 2 * spec_index]
                ExtField alpha_denominator = alpha_pows[initial_prod_evals_len + 2 * spec_index + 1]
                ExtField p1 = tower_proofs.logup_specs_eval[spec_index][round][0]
                ExtField p2 = tower_proofs.logup_specs_eval[spec_index][round][1]
                ExtField q1 = tower_proofs.logup_specs_eval[spec_index][round][2]
                ExtField q2 = tower_proofs.logup_specs_eval[spec_index][round][3]
                // expected_evaluation = expected_evaluation + eq_eval(rt_len, out_rt, rt) * (alpha_numerator * (p1 * q2 + p2 * q1) + alpha_denominator * (q1 * q2))
                expected_evaluation = ext_add(expected_evaluation, ext_add(ext_mul(eq_eval(rt_len, out_rt, rt), ext_mul(alpha_numerator, ext_add((ext_mul(p1, q2), ext_mul(p2, q1)))), ext_mul(alpha_denominator, ext_mul(q1, q2)))))
            endif
        endfor
        assert(ext_eq(expected_evaluation, sumcheck_claim.expected_evaluation) == 1)

        // derive single eval
        // rt' = r_merge || rt
        // r_merge.len() == ceil_log2(num_product_fanin)
        array_decl ExtField[log2_num_fanin] r_merge
        array_decl ExtField[rt_len + log2_num_fanin] rt_prime
        for u32 i in 0..rt_len do
            rt_prime[i] = rt[i]
        endfor
        for u32 i in 0..log2_num_fanin do
            TranscriptAndChallenge t0 = get_and_append_challenge(t, 1, [435527247213]) // b"merge"
            t = t0.transcript
            r_merge[i] = t0.challenge.elements
            rt_prime[rt_len + i] = t0.challenge.elements
        endfor
        ExtField[num_fanin] coeffs = build_eq_x_r_vec_sequential(log2_num_fanin, num_fanin, r_merge)

        // generate next round challenge
        ExtField prod_spec_evals = to_ext(0)
        for u32 spec_index in 0..tower_proofs.prod_spec_size do
            if tower_proofs.layer_per_spec[spec_index] < round then
                ExtField alpha = alpha_pows[spec_index]
                ExtField evals = to_ext(0)
                for u32 i in 0..eval_len do
                    evals = ext_add(evals, ext_mul(tower_proofs.prod_specs_eval[spec_index][round][i], coeffs[i]))
                endfor
                prod_spec_input_layer_eval[spec_index] = evals
                prod_spec_evals = ext_add(prod_spec_evals, ext_mul(alpha, evals))
            else
                prod_spec_input_layer_eval[spec_index] = tp_ext(0) 
            endif
        endfor
        ExtField logup_spec_evals = to_ext(0)
        for u32 spec_index in 0..tower_proofs.logup_spec_size do
            if tower_proofs.layer_per_spec[spec_index] < round then
                ExtField alpha_numerator = alpha_pows[initial_prod_evals_len + 2 * spec_index]
                ExtField alpha_denominator = alpha_pows[initial_prod_evals_len + 2 * spec_index + 1]
                // ExtField p_evals = tower_proofs.logup_specs_eval[spec_index][round][0] * coeffs[0] + tower_proofs.logup_specs_eval[spec_index][round][1] * coeffs[1]
                ExtField p_evals = ext_add(ext_mul(tower_proofs.logup_specs_eval[spec_index][round][0], coeffs[0]), ext_mul(tower_proofs.logup_specs_eval[spec_index][round][1], coeffs[1]))
                // ExtField q_evals = tower_proofs.logup_specs_eval[spec_index][round][2] * coeffs[0] + tower_proofs.logup_specs_eval[spec_index][round][3] * coeffs[1]
                ExtField q_evals = ext_add(ext_mul(tower_proofs.logup_specs_eval[spec_index][round][2], coeffs[0]), ext_mul(tower_proofs.logup_specs_eval[spec_index][round][3], coeffs[1]))
                logup_spec_p_input_layer_eval[spec_index] = p_evals
                logup_spec_q_input_layer_eval[spec_index] = q_evals
                // logup_spec_evals = logup_spec_evals + alpha_numerator * p_evals + alpha_denominator * q_evals
                logup_spec_evals = ext_add(logup_spec_evals, ext_add(ext_mul(alpha_numerator, p_evals), ext_mul(alpha_denominator, q_evals)))
            else 
                logup_spec_p_input_layer_eval[spec_index] = to_ext(0) 
                logup_spec_q_input_layer_eval[spec_index] = to_ext(0)
            endif
        endfor

        ExtField next_eval = ext_add(prod_spec_evals, logup_spec_evals)
        next_rt = PointAndEval {
            point: rt_prime,
            eval: next_eval
        }
        eval_len = eval_len * num_fanin
    endfor

    return TowerVerifierOutput {
        rt_tower: next_rt.point,
        record_evals: prod_spec_input_layer_eval,
        logup_p_evals: logup_spec_p_input_layer_eval,
        logup_q_evals: logup_spec_q_input_layer_eval
    }

def main() -> u32:
    field[1][2] initial_prod_evals = [[1, 0]]
    field[1][2] initial_logup_evals = [[1, 2, 1, 2]]
    TowerProofs tower_proofs = TowerProofs {
        prod_spec_size: 1,
        logup_spec_size: 1,
        proofs: [[IOPProverMessage {
            evaluations: [1, 2, 3]
        }; 3]],
        layer_per_spec: [1],
        prod_specs_eval: [[[0]]],
        logup_specs_eval: [[[0, 0, 0, 0]]]
    }
    u32 expected_max_round = 2
    Transcript t = new_transcript()
    TowerVerifierOutput output = tower_verify(initial_prod_evals, initial_logup_evals, tower_proofs, expected_max_round, t)

    return 1