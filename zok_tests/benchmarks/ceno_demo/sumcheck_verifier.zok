from "transcript" import Transcript, append_message_u32, append_message_field
from "sumcheck_structs" import SumcheckProof, IOPProverMessage, VPAuxInfo, SumCheckSubClaim, SumcheckIOPVerifierState

def verify_round_and_update_state(SumcheckIOPVerifierState self, IOPProverMessage prover_msg, Transcript transcript) -> SumcheckIOPVerifierState:
    // BLOCK 8
    assert(!self.finished)

    // In an interactive protocol, the verifier should
    //
    // 1. check if the received 'P(0) + P(1) = expected`.
    // 2. set `expected` to P(r)`
    //
    // When we turn the protocol to a non-interactive one, it is sufficient to defer
    // such checks to `check_and_generate_subclaim` after the last round.
    field challenge = transcript.hash
    self.challenges[self.round - 1] = challenge
    self.polynomials_received[self.round - 1] = prover_msg.evaluations

    if self.round == self.num_vars then
        // accept and close
        self.finished = true
    else
        // proceed to the next round
        self.round = self.round + 1
    endif
    return self

def interpolate_uni_poly(u32 p_i_len, field[0] p_i, field eval_at) -> field:
    // BLOCK 9
    u32 len = p_i_len
    array_decl field[len] evals
    field prod = eval_at
    evals[0] = eval_at

    // `prod = \prod_{j} (eval_at - j)`
    for u32 e in 1..len do
        // BLOCK 10, for loop
        field tmp = eval_at - (F)e
        evals[e] = tmp
        prod = prod * tmp
    endfor
    // BLOCK 11
    field res = 0
    // denom_up = field_factorial(len - 1)
    field denom_up = 1
    for u32 i in 2..len do
        // BLOCK 12, for loop
        denom_up = denom_up * (F)i
    endfor
    // BLOCK 13
    field denom_down = 1

    u32 it = len
    while it > 0 do
        // BLOCK 14, while loop
        u32 i = it - 1
        res = res + p_i[i] * prod * denom_down / (denom_up * evals[i])

        // compute denom for the next step is current_denom * (len-i)/i
        if i != 0 then
            denom_up = -1 * denom_up * (F)(len - i)
            denom_down = denom_down * (F)i
        endif
        it = it - 1
    endwhile
    // BLOCK 15
    return res

def check_and_generate_subclaim(SumcheckIOPVerifierState self, field asserted_sum) -> SumCheckSubClaim:
    // BLOCK 16
    assert(self.finished)
    // assert(self.polynomials_received.len() == self.num_vars)

    // the deferred check during the interactive phase:
    // 2. set `expected` to P(r)`

    array_decl field[self.num_vars + 1] expected_vec
    for u32 i in 0..self.num_vars do
        // BLOCK 17
        field[self.max_degree + 1] evaluations = self.polynomials_received[i]
        field challenge = self.challenges[i]
        // assert(evaluations.len() == self.max_degree + 1)
        expected_vec[i + 1] = interpolate_uni_poly(self.max_degree + 1, evaluations, challenge)
        // BLOCK 18, handle function return
    endfor

    // BLOCK 19
    // insert the asserted_sum to the first position of the expected vector
    expected_vec[0] = asserted_sum

    for u32 i in 0..self.num_vars do
        // BLOCK 20, for loop
        field[self.max_degree + 1] evaluations = self.polynomials_received[i]
        field expected = expected_vec[i]
        assert(evaluations[0] + evaluations[1] == expected)
    endfor

    // BLOCK 21
    return SumCheckSubClaim {
        point: self.challenges,
        // the last expected value (not checked within this function) will be included in the
        // subclaim
        expected_evaluation: expected_vec[self.num_vars]
    }

def verify_sumcheck(field claimed_sum, SumcheckProof proof, VPAuxInfo aux_info, Transcript t) -> SumCheckSubClaim:
    // BLOCK 22
    if aux_info.num_variables == 0 then
        return SumCheckSubClaim {
            point: [],
            expected_evaluation: claimed_sum
        }
    endif
    // BLOCK 23
    t = append_message_u32(t, aux_info.num_variables)
    // BLOCK 24
    t = append_message_u32(t, aux_info.max_degree)

    // BLOCK 25
    SumcheckIOPVerifierState vs = SumcheckIOPVerifierState {
        round: 1,
        num_vars: aux_info.num_variables,
        max_degree: aux_info.max_degree,
        finished: false,
        // BLOCK 26, 27, 28, 29, 30 handles constructions of polynomial_received & challenges
        // There are probably more efficient ways to do this (maybe skip initialization altogether?)
        polynomials_received: [[0; aux_info.max_degree + 1]; aux_info.num_variables],
        challenges: [0; aux_info.num_variables]
    }
    // BLOCK 31, copies all initialized values to vs, initialize outer loop
    for u32 i in 0..aux_info.num_variables do
        // BLOCK 32, initialize inner loop
        IOPProverMessage prover_msg = proof.proofs[i]
        for u32 j in 0..aux_info.max_degree + 1 do
            // BLOCK 33, handle function call
            t = append_message_field(t, prover_msg.evaluations[j])
            // BLOCK 34, handle function return
        endfor
        // BLOCK 35, handle function call parameters (self = vs)
        vs = verify_round_and_update_state(vs, prover_msg, t)
        // BLOCK 36, handle function return (vs = ret)
    endfor

    // BLOCK 37, handle function call parameters (self = vs)
    SumCheckSubClaim sc = check_and_generate_subclaim(vs, claimed_sum)
    // BLOCK 38, handle function return (sc = ret)
    return sc

def main(u32 num_vars, u32 max_degree, u32 i) -> field:
    // Generate polynomials
    array_decl field[max_degree + 1] pr0
    array_decl field[max_degree + 1] pr1
    array_decl field[max_degree + 1] pr2
    pr0[0] = 1
    pr0[1] = 2
    pr0[2] = 3
    pr1[0] = 6
    pr1[1] = 6
    pr1[2] = 6
    pr2[0] = 3
    pr2[1] = 3
    pr2[2] = 5
    IOPProverMessage pm0 = IOPProverMessage {
        evaluations: pr0
    }
    IOPProverMessage pm1 = IOPProverMessage {
        evaluations: pr1
    }
    IOPProverMessage pm2 = IOPProverMessage {
        evaluations: pr2
    }

    // Generate structs
    field claimed_sum = 3
    SumcheckProof proof = SumcheckProof {
        points: [11; num_vars],
        proofs: [pm0; num_vars]
    }
    proof.points[1] = 29
    proof.proofs[1] = pm1
    proof.points[2] = 40
    proof.proofs[2] = pm2
    VPAuxInfo aux_info = VPAuxInfo {
        max_degree: max_degree,
        num_variables: num_vars,
    }
    Transcript t = Transcript {
        hash: 0
    }

    SumCheckSubClaim sc = verify_sumcheck(claimed_sum, proof, aux_info, t)
    return sc.point[i] * 1000 + sc.expected_evaluation