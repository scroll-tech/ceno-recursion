def compress(u32 n, u32[300] txt, u32[600] compr) -> u32:
    // worst case is no compression, in which case we actually double
    // the size of the string!  Note that we could avoid this with a
    // different encoding strategy, but for our purposes the *performance*
    // of the two strategies is little different, and no one is sweating
    // our Weissman Score here. ;)
    u32 next_c = 0
    u32 next_t = 0
    u32 next_data = txt[0]
    u32 next_count = 0

    for u32 counter in 0..600 do
        if next_t < n then
            if txt[next_t] == next_data then
                next_count = next_count + 1
            else
                compr[next_c] = next_data
                compr[next_c + 1] = next_count
                next_c = next_c + 2
                next_data = txt[next_t]
                next_count = 1
            endif
            next_t = next_t + 1
        endif
    endfor


    // write out the last one
    compr[next_c] = next_data
    compr[next_c + 1] = next_count
    next_c = next_c + 2
    
    return next_c

def decompress(u32 m, u32[600] compr, u32[300] out) -> u32:
    u32 next_c = 0
    u32 next_t = 0

    // Use state machine
    u32 next_data = 0
    u32 next_count = 0
    u32 state = 0
    for u32 counter in 0..300 do
        if next_c < m then
            if state == 0 then
                next_data = compr[next_c]
                next_count = compr[next_c + 1]
                state = next_count > 0 ? 1 : 2
            endif
            if state == 1 then
                out[next_t] = next_data
                next_t = next_t + 1
                next_count = next_count - 1
                state = next_count > 0 ? 1 : 2
            endif
            if state == 2 then
                next_c = next_c + 2
                state = 0
            endif
        endif
    endfor


    return next_t

def main(u32 x, u32 y, u32 n) -> u32:
    u32[300] txt = [0; 300]

    // Initialize array
    u32 next_gap = 1
    u32 gap = next_gap
    for u32 i in 0..300 do
        txt[i] = next_gap
        gap = gap - 1
        if gap == 0 then
            next_gap = next_gap + 1
            gap = next_gap
        endif
    endfor

    // compress
    u32[600] compr = [0; 600]
    u32 m = compress(n, txt, compr)

    // decompress
    u32[300] out = [0; 300]
    u32 p = decompress(m, compr, out)

    assert(n == p)
    for u32 i in 0..300 do
        if i < n then
            assert(txt[i] == out[i])
            i = i + 1
        endif
    endfor


    return (txt[x] + compr[x] + out[x]) * y 