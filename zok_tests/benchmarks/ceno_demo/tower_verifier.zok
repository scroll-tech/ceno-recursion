from "transcript" import Transcript, append_message_u32, append_message_field
from "sumcheck_structs" import IOPProverMessage, SumcheckProof, VPAuxInfo, SumCheckSubClaim, SumcheckIOPVerifierState
from "sumcheck_verifier" import verify_round_and_update_state, interpolate_uni_poly, check_and_generate_subclaim, verify_sumcheck
from "mle" import mle_eval, eq_eval, build_eq_x_r_vec_sequential
from "tower_struct" import TowerProofs, TowerVerifierOutput, PointAndEval

def tower_verify(
    field[0][0] initial_prod_evals,
    field[0][0] initial_logup_evals,
    TowerProofs tower_proofs,
    u32 expected_max_round,
    u32 num_fanin,
    u32 log2_num_fanin,
    Transcript t
) -> TowerVerifierOutput:
    // XXX to sumcheck batched product argument with logup, we limit num_product_fanin to 2
    // TODO mayber give a better naming?
    // Assert num_fanin is a power of 2
    assert(num_fanin == 2)
    assert(log2_num_fanin == 1)

    // sanity check
    /*
    assert!(initial_prod_evals.len() == tower_proofs.prod_spec_size());
    assert!(
        initial_prod_evals
            .iter()
            .all(|evals| evals.len() == num_fanin)
    );
    assert!(initial_logup_evals.len() == tower_proofs.logup_spec_size());
    assert!(initial_logup_evals.iter().all(|evals| {
        evals.len() == 4 // [p1, p2, q1, q2]
    }));
    */
    u32 initial_prod_evals_len = tower_proofs.prod_spec_size
    u32 initial_logup_evals_len = tower_proofs.logup_spec_size

    // get_challenge_pows
    // decimal expression of "combine subset evals"
    t = append_message_field(t, 567674997755577675492904462386182052033524231283)
    /* --
    // field alpha = t.hash
    */

    field alpha = 1
    array_decl field[initial_prod_evals_len + initial_logup_evals_len * 2] alpha_pows
    field state = 1
    for u32 i in 0..initial_prod_evals_len + initial_logup_evals_len * 2 do
        alpha_pows[i] = state
        state = state * alpha
    endfor

    array_decl field[log2_num_fanin] initial_rt
    for u32 i in 0..log2_num_fanin do
        // decimal expression of "product_sum"
        t = append_message_field(t, 135940096403279116418381165)
        /* --
        // initial_rt[i] = t.hash
        */
        initial_rt[i] = 0
    endfor

    // --

    // initial_claim = \sum_j alpha^j * out_j[rt]
    // out_j[rt] := (record_{j}[rt])
    // out_j[rt] := (logup_p{j}[rt])
    // out_j[rt] := (logup_q{j}[rt])
    field initial_claim = 0
    for u32 i in 0..initial_prod_evals_len do
        field[0] evals = initial_prod_evals[i]
        field alpha = alpha_pows[i]
        initial_claim = initial_claim + mle_eval(evals, num_fanin, initial_rt, log2_num_fanin) * alpha
    endfor
    for u32 i in 0..initial_logup_evals_len do
        field alpha_numerator = alpha_pows[initial_prod_evals_len + 2 * i]
        field alpha_denominator = alpha_pows[initial_prod_evals_len + 2 * i + 1]
        field[2] mle_numerator = [initial_logup_evals[i][0], initial_logup_evals[i][1]]
        field[2] mle_denominator = [initial_logup_evals[i][2], initial_logup_evals[i][3]]
        initial_claim = initial_claim + mle_eval(mle_numerator, num_fanin, initial_rt, log2_num_fanin) * alpha_numerator
        initial_claim = initial_claim + mle_eval(mle_denominator, num_fanin, initial_rt, log2_num_fanin) * alpha_denominator
    endfor

    // evaluation in the tower input layer
    array_decl field[tower_proofs.prod_spec_size] prod_spec_input_layer_eval
    array_decl field[tower_proofs.logup_spec_size] logup_spec_p_input_layer_eval
    array_decl field[tower_proofs.logup_spec_size] logup_spec_q_input_layer_eval

    PointAndEval next_rt = PointAndEval {
        point: initial_rt,
        eval: initial_claim
    }
    u32 eval_len = 1
    for u32 round in 0..expected_max_round - 1 do
        field[0] out_rt = next_rt.point
        field out_claim = next_rt.eval
        u32 rt_len = (round + 1) * log2_num_fanin
        SumCheckSubClaim sumcheck_claim = verify_sumcheck(
            out_claim,
            SumcheckProof {
                points: [], // final claimed point will be derive from sumcheck protocol
                proofs: tower_proofs.proofs[round]
            },
            VPAuxInfo {
                max_degree: num_fanin + 1, // + 1 for eq
                num_variables: rt_len
            },
            t
        )

        // check expected_evaluation
        field[0] rt = sumcheck_claim.point
        field expected_evaluation = 0
        for u32 spec_index in 0..tower_proofs.prod_spec_size do
            field alpha = alpha_pows[spec_index]
            field prod = 1
            for u32 i in 0..eval_len do
                prod = prod * tower_proofs.prod_specs_eval[spec_index][round][i]
            endfor
            expected_evaluation = expected_evaluation + eq_eval(rt_len, out_rt, rt) * alpha * prod
        endfor
        for u32 spec_index in 0..tower_proofs.logup_spec_size do
            field alpha_numerator = alpha_pows[initial_prod_evals_len + 2 * spec_index]
            field alpha_denominator = alpha_pows[initial_prod_evals_len + 2 * spec_index + 1]
            field p1 = tower_proofs.logup_specs_eval[spec_index][round][0]
            field p2 = tower_proofs.logup_specs_eval[spec_index][round][1]
            field q1 = tower_proofs.logup_specs_eval[spec_index][round][2]
            field q2 = tower_proofs.logup_specs_eval[spec_index][round][3]
            expected_evaluation = expected_evaluation + eq_eval(rt_len, out_rt, rt) * (alpha_numerator * (p1 * q2 + p2 * q1) + alpha_denominator * (q1 * q2))
        endfor
        assert(expected_evaluation == sumcheck_claim.expected_evaluation)

        // derive single eval
        // rt' = r_merge || rt
        // r_merge.len() == ceil_log2(num_product_fanin)
        array_decl field[log2_num_fanin] r_merge
        for u32 i in 0..log2_num_fanin do
            // decimal expression of "merge"
            t = append_message_field(t, 469853431653)
            r_merge[i] = t.hash
        endfor
        field[num_fanin] coeffs = build_eq_x_r_vec_sequential(log2_num_fanin, num_fanin, r_merge)
        array_decl field[rt_len + log2_num_fanin] rt_prime
        for u32 i in 0..rt_len do
            rt_prime[i] = rt[i]
        endfor
        for u32 i in 0..log2_num_fanin do
            rt_prime[rt_len + i] = r_merge[i]
        endfor

        field prod_spec_evals = 0
        for u32 spec_index in 0..tower_proofs.prod_spec_size do
            // if round < tower_proofs.prod_specs_eval[spec_index].len()
            field alpha = alpha_pows[spec_index]
            field evals = 0
            for u32 i in 0..eval_len do
                evals = evals + tower_proofs.prod_specs_eval[spec_index][round][i] * coeffs[i]
            endfor
            prod_spec_input_layer_eval[spec_index] = evals
            prod_spec_evals = prod_spec_evals + alpha * evals
            // else { 
            //     prod_spec_input_layer_eval[spec_index] = 0 
            // }
        endfor
        field logup_spec_evals = 0
        for u32 spec_index in 0..tower_proofs.logup_spec_size do
            // if round < tower_proofs.logup_specs_eval[spec_index].len()
            field alpha_numerator = alpha_pows[initial_prod_evals_len + 2 * spec_index]
            field alpha_denominator = alpha_pows[initial_prod_evals_len + 2 * spec_index + 1]
            field p_evals = tower_proofs.logup_specs_eval[spec_index][round][0] * coeffs[0] + tower_proofs.logup_specs_eval[spec_index][round][1] * coeffs[1]
            field q_evals = tower_proofs.logup_specs_eval[spec_index][round][2] * coeffs[0] + tower_proofs.logup_specs_eval[spec_index][round][3] * coeffs[1]
            logup_spec_p_input_layer_eval[spec_index] = p_evals
            logup_spec_q_input_layer_eval[spec_index] = q_evals
            logup_spec_evals = logup_spec_evals + alpha_numerator * p_evals + alpha_denominator * q_evals
            // else { 
            //     logup_spec_p_input_layer_eval[spec_index] = 0 
            //     logup_spec_q_input_layer_eval[spec_index] = 0
            // }
        endfor

        field next_eval = prod_spec_evals + logup_spec_evals
        next_rt = PointAndEval {
            point: rt_prime,
            eval: next_eval
        }
        eval_len = eval_len * num_fanin
    endfor

    return TowerVerifierOutput {
        rt_tower: next_rt.point,
        record_evals: prod_spec_input_layer_eval,
        logup_p_evals: logup_spec_p_input_layer_eval,
        logup_q_evals: logup_spec_q_input_layer_eval
    }

def main() -> u32:
    field[1][2] initial_prod_evals = [[1, 0]]
    field[1][2] initial_logup_evals = [[1, 2, 1, 2]]
    TowerProofs tower_proofs = TowerProofs {
        prod_spec_size: 1,
        logup_spec_size: 1,
         proofs: [[IOPProverMessage {
            evaluations: [1, 2, 3]
        }; 3]],
        prod_specs_eval: [],
        logup_specs_eval: []
    }
    u32 expected_max_round = 2
    u32 num_fanin = 2
    u32 log2_num_fanin = 1
    Transcript t = Transcript {
        hash: 0
    }
    TowerVerifierOutput output = tower_verify(initial_prod_evals, initial_logup_evals, tower_proofs, expected_max_round, num_fanin, log2_num_fanin, t)

    return 1